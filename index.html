<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”»åƒä¸‰è§’å½¢å¤‰æ›</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }
        input[type="file"] {
            display: none;
        }
        .file-label {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 500;
        }
        .file-label:hover {
            transform: translateY(-2px);
        }
        input[type="range"] {
            width: 200px;
        }
        .value-display {
            text-align: center;
            font-weight: bold;
            color: #764ba2;
        }
        button {
            padding: 10px 25px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            transition: transform 0.2s;
            font-weight: 500;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .canvas-wrapper {
            position: relative;
            background: #f5f5f5;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .canvas-wrapper h3 {
            margin: 0 0 10px 0;
            color: #555;
            text-align: center;
        }
        canvas {
            display: block;
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border-radius: 10px;
            text-align: center;
            color: #333;
        }
        @media (max-width: 768px) {
            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ ç”»åƒä¸‰è§’å½¢å¤‰æ›ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="imageInput" class="file-label">
                    ğŸ“· ç”»åƒã‚’é¸æŠ
                </label>
                <input type="file" id="imageInput" accept="image/*">
            </div>
            
            <div class="control-group">
                <label>ä¸‰è§’å½¢ã®æ•°</label>
                <input type="range" id="pointCount" min="10" max="3000" value="100">
                <div class="value-display" id="pointValue">100</div>
            </div>
            
            <div class="control-group">
                <label>ã‚¨ãƒƒã‚¸æ¤œå‡ºæ„Ÿåº¦</label>
                <input type="range" id="edgeSensitivity" min="0" max="100" value="50">
                <div class="value-display" id="edgeValue">50</div>
            </div>
            
            <button id="processBtn">å¤‰æ›å®Ÿè¡Œ</button>
            <button id="downloadSvgBtn" style="display: none;">SVGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        </div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>å…ƒç”»åƒ</h3>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>ä¸‰è§’å½¢å¤‰æ›å¾Œ</h3>
                <canvas id="resultCanvas"></canvas>
            </div>
        </div>
        
        <div class="info" id="info">
            ç”»åƒã‚’é¸æŠã—ã¦ã€Œå¤‰æ›å®Ÿè¡Œã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„
        </div>
        
        <div class="algorithm-explanation" style="margin-top: 40px; padding: 30px; background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); border-radius: 15px;">
            <h2 style="color: #5e35b1; margin-bottom: 20px;">ğŸ“ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ä»•çµ„ã¿</h2>
            
            <div style="margin-bottom: 25px;">
                <h3 style="color: #7e57c2; margin-bottom: 10px;">1. é ‚ç‚¹ã®é…ç½®</h3>
                <p style="line-height: 1.6; color: #424242;">
                    ã¾ãšã€ä¸‰è§’å½¢ã®é ‚ç‚¹ã¨ãªã‚‹ç‚¹ã‚’ç”»åƒä¸Šã«é…ç½®ã—ã¾ã™ã€‚ã“ã®é…ç½®æ–¹æ³•ã¯3ã¤ã®æˆ¦ç•¥ã‚’çµ„ã¿åˆã‚ã›ã¦ã„ã¾ã™ï¼š
                </p>
                <ul style="line-height: 1.8; color: #616161;">
                    <li><strong>å›ºå®šé ‚ç‚¹ï¼š</strong>ç”»åƒã®å››éš…ã«å¿…ãšé ‚ç‚¹ã‚’é…ç½®ï¼ˆç”»åƒå…¨ä½“ã‚’ã‚«ãƒãƒ¼ã™ã‚‹ãŸã‚ï¼‰</li>
                    <li><strong>ã‚¨ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹é ‚ç‚¹ï¼š</strong>Sobelãƒ•ã‚£ãƒ«ã‚¿ã§ã‚¨ãƒƒã‚¸ï¼ˆè¼ªéƒ­ï¼‰ã‚’æ¤œå‡ºã—ã€è¼ªéƒ­ã®å¼·ã„éƒ¨åˆ†ã«å„ªå…ˆçš„ã«é ‚ç‚¹ã‚’é…ç½®</li>
                    <li><strong>ãƒ©ãƒ³ãƒ€ãƒ é ‚ç‚¹ï¼š</strong>æ®‹ã‚Šã®é ‚ç‚¹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ã—ã¦å…¨ä½“ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚‹</li>
                </ul>
                <p style="line-height: 1.6; color: #424242; margin-top: 10px;">
                    ã€Œã‚¨ãƒƒã‚¸æ¤œå‡ºæ„Ÿåº¦ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ã‚¨ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹é ‚ç‚¹ã¨ãƒ©ãƒ³ãƒ€ãƒ é ‚ç‚¹ã®æ¯”ç‡ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚é«˜ã„å€¤ã«ã™ã‚‹ã¨ã€è¼ªéƒ­éƒ¨åˆ†ã«ã‚ˆã‚Šå¤šãã®é ‚ç‚¹ãŒé›†ä¸­ã—ã€ç´°éƒ¨ãŒä¿æŒã•ã‚Œã¾ã™ã€‚
                </p>
            </div>
            
            <div style="margin-bottom: 25px;">
                <h3 style="color: #7e57c2; margin-bottom: 10px;">2. Delaunayä¸‰è§’åˆ†å‰²</h3>
                <p style="line-height: 1.6; color: #424242;">
                    é…ç½®ã•ã‚ŒãŸé ‚ç‚¹ã‹ã‚‰ä¸‰è§’å½¢ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆã—ã¾ã™ã€‚Delaunayä¸‰è§’åˆ†å‰²ã¯ã€ä»¥ä¸‹ã®ç‰¹æ€§ã‚’æŒã¤æœ€é©ãªä¸‰è§’å½¢åˆ†å‰²æ‰‹æ³•ã§ã™ï¼š
                </p>
                <ul style="line-height: 1.8; color: #616161;">
                    <li><strong>å¤–æ¥å††æ¡ä»¶ï¼š</strong>å„ä¸‰è§’å½¢ã®å¤–æ¥å††å†…ã«ä»–ã®é ‚ç‚¹ãŒå«ã¾ã‚Œãªã„</li>
                    <li><strong>è§’åº¦ã®æœ€å¤§åŒ–ï¼š</strong>ç´°é•·ã„ä¸‰è§’å½¢ã‚’é¿ã‘ã€ã§ãã‚‹ã ã‘æ­£ä¸‰è§’å½¢ã«è¿‘ã„å½¢çŠ¶ã‚’ç”Ÿæˆ</li>
                    <li><strong>ä¸€æ„æ€§ï¼š</strong>ä¸ãˆã‚‰ã‚ŒãŸç‚¹é›†åˆã«å¯¾ã—ã¦ã€å”¯ä¸€ã®ä¸‰è§’åˆ†å‰²ã‚’ç”Ÿæˆ</li>
                </ul>
                <p style="line-height: 1.6; color: #424242; margin-top: 10px;">
                    å®Ÿè£…ã§ã¯ã€Bowyer-Watsonã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚æ–°ã—ã„é ‚ç‚¹ã‚’è¿½åŠ ã™ã‚‹ãŸã³ã«ã€ãã®ç‚¹ã‚’å«ã‚€å¤–æ¥å††ã‚’æŒã¤ã€Œä¸æ­£ãªã€ä¸‰è§’å½¢ã‚’å‰Šé™¤ã—ã€æ–°ã—ã„ä¸‰è§’å½¢ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
                </p>
            </div>
            
            <div style="margin-bottom: 25px;">
                <h3 style="color: #7e57c2; margin-bottom: 10px;">3. è‰²ã®è¿‘ä¼¼</h3>
                <p style="line-height: 1.6; color: #424242;">
                    å„ä¸‰è§’å½¢ã‚’å˜ä¸€ã®è‰²ã§å¡—ã‚Šã¤ã¶ã—ã¾ã™ã€‚ã“ã®è‰²ã¯ä»¥ä¸‹ã®æ‰‹é †ã§æ±ºå®šã•ã‚Œã¾ã™ï¼š
                </p>
                <ol style="line-height: 1.8; color: #616161;">
                    <li>ä¸‰è§’å½¢ã®å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼ˆæœ€å°ãƒ»æœ€å¤§åº§æ¨™ï¼‰ã‚’è¨ˆç®—</li>
                    <li>ä¸‰è§’å½¢å†…éƒ¨ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆè¨ˆç®—åŠ¹ç‡ã®ãŸã‚2ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ï¼‰</li>
                    <li>ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ãŸãƒ”ã‚¯ã‚»ãƒ«ã®RGBå€¤ã®å¹³å‡ã‚’è¨ˆç®—</li>
                    <li>ä¸‰è§’å½¢ãŒå°ã•ã™ãã‚‹å ´åˆã¯ã€é‡å¿ƒä½ç½®ã®è‰²ã‚’ä½¿ç”¨</li>
                </ol>
            </div>
            
            <div style="margin-bottom: 25px;">
                <h3 style="color: #7e57c2; margin-bottom: 10px;">4. ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆSobelãƒ•ã‚£ãƒ«ã‚¿ï¼‰</h3>
                <p style="line-height: 1.6; color: #424242;">
                    ç”»åƒã®è¼ªéƒ­ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã€ç°¡æ˜“ç‰ˆã®Sobelãƒ•ã‚£ãƒ«ã‚¿ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼š
                </p>
                <ul style="line-height: 1.8; color: #616161;">
                    <li>å„ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ã«å¤‰æ›ï¼ˆè¼åº¦ = 0.299R + 0.587G + 0.114Bï¼‰</li>
                    <li>æ°´å¹³æ–¹å‘ã®å‹¾é…ï¼ˆGxï¼‰= å³å´ã®è¼åº¦ - å·¦å´ã®è¼åº¦</li>
                    <li>å‚ç›´æ–¹å‘ã®å‹¾é…ï¼ˆGyï¼‰= ä¸‹å´ã®è¼åº¦ - ä¸Šå´ã®è¼åº¦</li>
                    <li>ã‚¨ãƒƒã‚¸ã®å¼·åº¦ = âˆš(GxÂ² + GyÂ²)</li>
                </ul>
            </div>
            
            <div style="padding: 20px; background: rgba(255, 255, 255, 0.5); border-radius: 10px;">
                <h3 style="color: #7e57c2; margin-bottom: 10px;">ğŸ’¡ å¿œç”¨ã¨åŠ¹æœ</h3>
                <p style="line-height: 1.6; color: #424242;">
                    ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ŒLow-Polyï¼ˆãƒ­ãƒ¼ãƒãƒªï¼‰ã€ã‚¢ãƒ¼ãƒˆåŠ¹æœã‚’ç”Ÿæˆã—ã€ä»¥ä¸‹ã®ã‚ˆã†ãªç”¨é€”ãŒã‚ã‚Šã¾ã™ï¼š
                </p>
                <ul style="line-height: 1.8; color: #616161;">
                    <li><strong>ã‚¢ãƒ¼ãƒˆåŠ¹æœï¼š</strong>å†™çœŸã‚’ã‚¹ã‚¿ã‚¤ãƒ©ã‚¤ã‚ºã•ã‚ŒãŸå¹¾ä½•å­¦çš„ãªã‚¢ãƒ¼ãƒˆã«å¤‰æ›</li>
                    <li><strong>ç”»åƒåœ§ç¸®ï¼š</strong>å°‘ãªã„ä¸‰è§’å½¢ã§ç”»åƒã‚’è¿‘ä¼¼è¡¨ç¾ï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼åŒ–ï¼‰</li>
                    <li><strong>ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆï¼š</strong>3Dãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã‚„ã‚²ãƒ¼ãƒ é–‹ç™ºã§ã®åŸºç¤ãƒ¡ãƒƒã‚·ãƒ¥ä½œæˆ</li>
                    <li><strong>ç”»åƒè§£æï¼š</strong>é‡è¦ãªç‰¹å¾´ã‚’ä¿æŒã—ãªãŒã‚‰æƒ…å ±ã‚’ç°¡ç•¥åŒ–</li>
                </ul>
                <p style="line-height: 1.6; color: #424242; margin-top: 10px;">
                    ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª¿æ•´ã™ã‚‹ã“ã¨ã§ã€æŠ½è±¡çš„ãªã‚¢ãƒ¼ãƒˆé¢¨ã‹ã‚‰ã€ã‚ˆã‚Šå†™å®Ÿçš„ãªè¡¨ç¾ã¾ã§ã€å¹…åºƒã„åŠ¹æœã‚’å¾—ã‚‰ã‚Œã¾ã™ã€‚ç‰¹ã«äººç‰©å†™çœŸã€é¢¨æ™¯ã€ã‚¤ãƒ©ã‚¹ãƒˆãªã©ã§èˆˆå‘³æ·±ã„çµæœãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚
                </p>
            </div>
            
            <div style="margin-top: 20px; padding: 20px; background: rgba(103, 58, 183, 0.1); border-radius: 10px; border: 2px solid #673ab7;">
                <h3 style="color: #673ab7; margin-bottom: 10px;">ğŸ“¥ SVGå‡ºåŠ›æ©Ÿèƒ½</h3>
                <p style="line-height: 1.6; color: #424242;">
                    å¤‰æ›å¾Œã®ç”»åƒã¯<strong>SVGï¼ˆScalable Vector Graphicsï¼‰å½¢å¼</strong>ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ã§ã™ã€‚
                    SVGã®ç‰¹å¾´ï¼š
                </p>
                <ul style="line-height: 1.8; color: #616161;">
                    <li><strong>ãƒ™ã‚¯ã‚¿ãƒ¼å½¢å¼ï¼š</strong>ã©ã‚“ãªã«æ‹¡å¤§ã—ã¦ã‚‚ç”»è³ªãŒåŠ£åŒ–ã—ãªã„</li>
                    <li><strong>ç·¨é›†å¯èƒ½ï¼š</strong>Adobe Illustratorã‚„Inkscapeã§å¾Œã‹ã‚‰ç·¨é›†ã§ãã‚‹</li>
                    <li><strong>è»½é‡ï¼š</strong>ä¸‰è§’å½¢ã®æ•°ãŒå°‘ãªã„å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå°ã•ã„</li>
                    <li><strong>Webè¦ªå’Œæ€§ï¼š</strong>HTMLã«ç›´æ¥åŸ‹ã‚è¾¼ã¿å¯èƒ½ã€CSSã§ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°å¯èƒ½</li>
                </ul>
                <p style="line-height: 1.6; color: #424242; margin-top: 10px;">
                    å¤‰æ›å®Ÿè¡Œå¾Œã«è¡¨ç¤ºã•ã‚Œã‚‹ã€ŒSVGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€ãƒœã‚¿ãƒ³ã‹ã‚‰ä¿å­˜ã§ãã¾ã™ã€‚
                </p>
            </div>
        </div>
    </div>

    <script>
        // Delaunayä¸‰è§’åˆ†å‰²ã®å®Ÿè£…
        class Delaunay {
            constructor(points) {
                this.points = points;
                this.triangles = [];
                this.superTriangle = null;
                this.compute();
            }
            
            compute() {
                if (this.points.length < 3) {
                    console.log('  è­¦å‘Š: é ‚ç‚¹æ•°ãŒ3æœªæº€ã®ãŸã‚ä¸‰è§’åˆ†å‰²ã‚’ã‚¹ã‚­ãƒƒãƒ—');
                    return;
                }
                
                console.log(`  ${this.points.length}å€‹ã®é ‚ç‚¹ã§Delaunayä¸‰è§’åˆ†å‰²ã‚’é–‹å§‹`);
                
                // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ã‚’ä½œæˆ
                const minX = Math.min(...this.points.map(p => p[0]));
                const minY = Math.min(...this.points.map(p => p[1]));
                const maxX = Math.max(...this.points.map(p => p[0]));
                const maxY = Math.max(...this.points.map(p => p[1]));
                
                const dx = maxX - minX;
                const dy = maxY - minY;
                const deltaMax = Math.max(dx, dy);
                const midX = (minX + maxX) / 2;
                const midY = (minY + maxY) / 2;
                
                const p1 = [midX - 20 * deltaMax, midY - deltaMax];
                const p2 = [midX, midY + 20 * deltaMax];
                const p3 = [midX + 20 * deltaMax, midY - deltaMax];
                
                // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ã®é ‚ç‚¹ã‚’ä¿å­˜
                this.superTriangle = [p1, p2, p3];
                this.triangles = [[p1, p2, p3]];
                console.log('  ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ä½œæˆå®Œäº†');
                
                // å„ç‚¹ã‚’è¿½åŠ 
                let processedPoints = 0;
                for (const point of this.points) {
                    this.addPoint(point);
                    processedPoints++;
                    if (processedPoints % 50 === 0) {
                        console.log(`  ä¸‰è§’åˆ†å‰²é€²æ—: ${processedPoints}/${this.points.length} é ‚ç‚¹å‡¦ç†æ¸ˆ`);
                    }
                }
                
                // ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ã«æ¥ç¶šã•ã‚ŒãŸä¸‰è§’å½¢ã‚’å‰Šé™¤
                const beforeCount = this.triangles.length;
                this.triangles = this.triangles.filter(tri => {
                    // ä¸‰è§’å½¢ã®é ‚ç‚¹ãŒã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ã®é ‚ç‚¹ã‚’å«ã‚€ã‹ãƒã‚§ãƒƒã‚¯
                    for (let vertex of tri) {
                        for (let superVertex of this.superTriangle) {
                            if (Math.abs(vertex[0] - superVertex[0]) < 0.01 && 
                                Math.abs(vertex[1] - superVertex[1]) < 0.01) {
                                return false;
                            }
                        }
                    }
                    return true;
                });
                console.log(`  ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«é–¢é€£ã®ä¸‰è§’å½¢ã‚’å‰Šé™¤: ${beforeCount} â†’ ${this.triangles.length}`);
                
                if (this.triangles.length === 0) {
                    console.log('  è­¦å‘Š: ã™ã¹ã¦ã®ä¸‰è§’å½¢ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚ãƒ‡ãƒãƒƒã‚°æƒ…å ±:');
                    console.log('    - å…¥åŠ›é ‚ç‚¹æ•°:', this.points.length);
                    console.log('    - å‰Šé™¤å‰ã®ä¸‰è§’å½¢æ•°:', beforeCount);
                }
            }
            
            addPoint(point) {
                const edges = [];
                const badTriangles = [];
                
                // å¤–æ¥å††å†…ã«ç‚¹ã‚’å«ã‚€ä¸‰è§’å½¢ã‚’æ¢ã™
                for (const tri of this.triangles) {
                    if (this.inCircumcircle(point, tri)) {
                        badTriangles.push(tri);
                        edges.push([tri[0], tri[1]]);
                        edges.push([tri[1], tri[2]]);
                        edges.push([tri[2], tri[0]]);
                    }
                }
                
                if (badTriangles.length === 0) {
                    console.log(`  è­¦å‘Š: ç‚¹ [${point[0].toFixed(1)}, ${point[1].toFixed(1)}] ã«å¯¾ã—ã¦ä¸æ­£ãªä¸‰è§’å½¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                    return;
                }
                
                // ä¸æ­£ãªä¸‰è§’å½¢ã‚’å‰Šé™¤
                this.triangles = this.triangles.filter(tri => !badTriangles.includes(tri));
                
                // é‡è¤‡ã™ã‚‹ã‚¨ãƒƒã‚¸ã‚’é™¤å»ï¼ˆå¢ƒç•Œã‚¨ãƒƒã‚¸ã®ã¿æ®‹ã™ï¼‰
                const polygon = [];
                for (let i = 0; i < edges.length; i++) {
                    if (edges[i] === null) continue;
                    
                    let isShared = false;
                    for (let j = i + 1; j < edges.length; j++) {
                        if (edges[j] !== null && this.edgesEqual(edges[i], edges[j])) {
                            edges[j] = null;  // é‡è¤‡ã™ã‚‹ã‚¨ãƒƒã‚¸ã‚’ãƒãƒ¼ã‚¯
                            isShared = true;
                            break;
                        }
                    }
                    
                    if (!isShared) {
                        polygon.push(edges[i]);
                    }
                }
                
                // æ–°ã—ã„ä¸‰è§’å½¢ã‚’ä½œæˆ
                for (const edge of polygon) {
                    const newTri = [edge[0], edge[1], point];
                    this.triangles.push(newTri);
                }
                
                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
                if (this.triangles.length === 0) {
                    console.log(`  ã‚¨ãƒ©ãƒ¼: ç‚¹è¿½åŠ å¾Œã«ä¸‰è§’å½¢ãŒ0å€‹ã«ãªã‚Šã¾ã—ãŸ`);
                    console.log(`    - å‰Šé™¤ã•ã‚ŒãŸä¸‰è§’å½¢: ${badTriangles.length}å€‹`);
                    console.log(`    - ãƒãƒªã‚´ãƒ³ã‚¨ãƒƒã‚¸: ${polygon.length}å€‹`);
                }
            }
            
            inCircumcircle(point, tri) {
                const [p1, p2, p3] = tri;
                
                // ä¸‰è§’å½¢ãŒæ™‚è¨ˆå›ã‚Šã‹åæ™‚è¨ˆå›ã‚Šã‹ãƒã‚§ãƒƒã‚¯
                const d = 2 * (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]));
                
                if (Math.abs(d) < 1e-10) {
                    // ä¸‰ç‚¹ãŒä¸€ç›´ç·šä¸Šã«ã‚ã‚‹
                    return false;
                }
                
                // å¤–æ¥å††ã®ä¸­å¿ƒã‚’è¨ˆç®—
                const ux = ((p1[0] * p1[0] + p1[1] * p1[1]) * (p2[1] - p3[1]) +
                           (p2[0] * p2[0] + p2[1] * p2[1]) * (p3[1] - p1[1]) +
                           (p3[0] * p3[0] + p3[1] * p3[1]) * (p1[1] - p2[1])) / d;
                
                const uy = ((p1[0] * p1[0] + p1[1] * p1[1]) * (p3[0] - p2[0]) +
                           (p2[0] * p2[0] + p2[1] * p2[1]) * (p1[0] - p3[0]) +
                           (p3[0] * p3[0] + p3[1] * p3[1]) * (p2[0] - p1[0])) / d;
                
                // å¤–æ¥å††ã®åŠå¾„ã®äºŒä¹—
                const r2 = (p1[0] - ux) * (p1[0] - ux) + (p1[1] - uy) * (p1[1] - uy);
                
                // ç‚¹ã‹ã‚‰å¤–æ¥å††ã®ä¸­å¿ƒã¾ã§ã®è·é›¢ã®äºŒä¹—
                const dist2 = (point[0] - ux) * (point[0] - ux) + (point[1] - uy) * (point[1] - uy);
                
                // ç‚¹ãŒå¤–æ¥å††å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                return dist2 < r2 - 1e-10;
            }
            
            edgesEqual(e1, e2) {
                return (e1[0] === e2[0] && e1[1] === e2[1]) ||
                       (e1[0] === e2[1] && e1[1] === e2[0]);
            }
        }
        
        // ãƒ¡ã‚¤ãƒ³å‡¦ç†
        let originalImage = null;
        let currentTriangles = null;  // ä¸‰è§’å½¢ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        let currentImageData = null;  // ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        let currentWidth = 0;
        let currentHeight = 0;
        
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        originalImage = img;
                        displayOriginal();
                        document.getElementById('info').textContent = 'ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚å¤‰æ›å®Ÿè¡Œã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚';
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        document.getElementById('pointCount').addEventListener('input', function(e) {
            document.getElementById('pointValue').textContent = e.target.value;
        });
        
        document.getElementById('edgeSensitivity').addEventListener('input', function(e) {
            document.getElementById('edgeValue').textContent = e.target.value;
        });
        
        document.getElementById('processBtn').addEventListener('click', processImage);
        document.getElementById('downloadSvgBtn').addEventListener('click', downloadSVG);
        
        function generateSVG(triangles, imageData, width, height) {
            let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svg += `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">\n`;
            svg += `  <rect width="${width}" height="${height}" fill="#f0f0f0"/>\n`;
            
            for (const triangle of triangles) {
                const color = getAverageColor(imageData, triangle, width, height);
                const points = `${triangle[0][0].toFixed(2)},${triangle[0][1].toFixed(2)} ${triangle[1][0].toFixed(2)},${triangle[1][1].toFixed(2)} ${triangle[2][0].toFixed(2)},${triangle[2][1].toFixed(2)}`;
                svg += `  <polygon points="${points}" fill="rgb(${color.r},${color.g},${color.b})" stroke="rgba(${color.r},${color.g},${color.b},0.5)" stroke-width="0.5"/>\n`;
            }
            
            svg += '</svg>';
            return svg;
        }
        
        function downloadSVG() {
            if (!currentTriangles || currentTriangles.length === 0) {
                alert('å…ˆã«ç”»åƒã‚’å¤‰æ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            console.log('SVGç”Ÿæˆé–‹å§‹...');
            const svgContent = generateSVG(currentTriangles, currentImageData, currentWidth, currentHeight);
            console.log(`SVGã‚µã‚¤ã‚º: ${(svgContent.length / 1024).toFixed(2)}KB`);
            
            // Blobã‚’ä½œæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `triangulated_${Date.now()}.svg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('SVGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†');
        }
        
        function displayOriginal() {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            const maxSize = 500;
            let width = originalImage.width;
            let height = originalImage.height;
            
            if (width > maxSize || height > maxSize) {
                const scale = Math.min(maxSize / width, maxSize / height);
                width *= scale;
                height *= scale;
            }
            
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(originalImage, 0, 0, width, height);
        }
        
        function processImage() {
            if (!originalImage) {
                alert('ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            console.log('=== ç”»åƒä¸‰è§’å½¢å¤‰æ›å‡¦ç†é–‹å§‹ ===');
            const startTime = performance.now();
            
            const pointCount = parseInt(document.getElementById('pointCount').value);
            const edgeSensitivity = parseInt(document.getElementById('edgeSensitivity').value) / 100;
            
            console.log(`è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:`, {
                pointCount: pointCount,
                edgeSensitivity: edgeSensitivity * 100 + '%',
                originalImageSize: `${originalImage.width}x${originalImage.height}`
            });
            
            document.getElementById('info').textContent = 'å‡¦ç†ä¸­...';
            document.getElementById('processBtn').disabled = true;
            
            setTimeout(() => {
                const canvas = document.getElementById('resultCanvas');
                const ctx = canvas.getContext('2d');
                
                const maxSize = 500;
                let width = originalImage.width;
                let height = originalImage.height;
                
                if (width > maxSize || height > maxSize) {
                    const scale = Math.min(maxSize / width, maxSize / height);
                    width *= scale;
                    height *= scale;
                }
                
                console.log(`å‡¦ç†ç”»åƒã‚µã‚¤ã‚º: ${width}x${height}`);
                
                canvas.width = width;
                canvas.height = height;
                
                // ä¸€æ™‚çš„ãªã‚­ãƒ£ãƒ³ãƒã‚¹ã§å…ƒç”»åƒã‚’æç”»
                console.log('ã‚¹ãƒ†ãƒƒãƒ—1: ç”»åƒãƒ‡ãƒ¼ã‚¿ã®æº–å‚™...');
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(originalImage, 0, 0, width, height);
                const imageData = tempCtx.getImageData(0, 0, width, height);
                console.log(`âœ“ ç”»åƒãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº† (${imageData.data.length / 4}ãƒ”ã‚¯ã‚»ãƒ«)`);
                
                // ã‚¨ãƒƒã‚¸æ¤œå‡ºã¨ç‚¹ã®ç”Ÿæˆ
                console.log('ã‚¹ãƒ†ãƒƒãƒ—2: ã‚¨ãƒƒã‚¸æ¤œå‡ºã¨é ‚ç‚¹ç”Ÿæˆ...');
                const pointGenStart = performance.now();
                const points = generatePoints(imageData, pointCount, edgeSensitivity);
                const pointGenTime = performance.now() - pointGenStart;
                console.log(`âœ“ ${points.length}å€‹ã®é ‚ç‚¹ã‚’ç”Ÿæˆ (${pointGenTime.toFixed(2)}ms)`);
                console.log(`  - ã‚¨ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹: ${Math.floor(pointCount * edgeSensitivity)}å€‹`);
                console.log(`  - ãƒ©ãƒ³ãƒ€ãƒ é…ç½®: ${pointCount - Math.floor(pointCount * edgeSensitivity) - 4}å€‹`);
                console.log(`  - å››éš…å›ºå®š: 4å€‹`);
                
                // Delaunayä¸‰è§’åˆ†å‰²
                console.log('ã‚¹ãƒ†ãƒƒãƒ—3: Delaunayä¸‰è§’åˆ†å‰²...');
                const delaunayStart = performance.now();
                const delaunay = new Delaunay(points);
                const delaunayTime = performance.now() - delaunayStart;
                console.log(`âœ“ ${delaunay.triangles.length}å€‹ã®ä¸‰è§’å½¢ã‚’ç”Ÿæˆ (${delaunayTime.toFixed(2)}ms)`);
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä¿å­˜ï¼ˆSVGå‡ºåŠ›ç”¨ï¼‰
                currentTriangles = delaunay.triangles;
                currentImageData = imageData;
                currentWidth = width;
                currentHeight = height;
                
                // SVGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                document.getElementById('downloadSvgBtn').style.display = 'inline-block';
                // ä¸‰è§’å½¢ã‚’æç”»
                console.log('ã‚¹ãƒ†ãƒƒãƒ—4: ä¸‰è§’å½¢ã®æç”»...');
                const renderStart = performance.now();
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, width, height);
                
                let processedTriangles = 0;
                for (const triangle of delaunay.triangles) {
                    // ä¸‰è§’å½¢ã®é‡å¿ƒã‚’è¨ˆç®—
                    const centerX = (triangle[0][0] + triangle[1][0] + triangle[2][0]) / 3;
                    const centerY = (triangle[0][1] + triangle[1][1] + triangle[2][1]) / 3;
                    
                    // é‡å¿ƒã®è‰²ã‚’å–å¾—
                    const color = getAverageColor(imageData, triangle, width, height);
                    
                    // ä¸‰è§’å½¢ã‚’å¡—ã‚Šã¤ã¶ã—
                    ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    ctx.beginPath();
                    ctx.moveTo(triangle[0][0], triangle[0][1]);
                    ctx.lineTo(triangle[1][0], triangle[1][1]);
                    ctx.lineTo(triangle[2][0], triangle[2][1]);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ä¸‰è§’å½¢ã®è¼ªéƒ­ç·šï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                    ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.5)`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                    
                    processedTriangles++;
                    if (processedTriangles % 50 === 0) {
                        console.log(`  æç”»é€²æ—: ${processedTriangles}/${delaunay.triangles.length} ä¸‰è§’å½¢`);
                    }
                }
                
                const renderTime = performance.now() - renderStart;
                console.log(`âœ“ å…¨ä¸‰è§’å½¢ã®æç”»å®Œäº† (${renderTime.toFixed(2)}ms)`);
                
                const totalTime = performance.now() - startTime;
                console.log(`=== å‡¦ç†å®Œäº† ===`);
                console.log(`ç·å‡¦ç†æ™‚é–“: ${totalTime.toFixed(2)}ms`);
                console.log(`å‡¦ç†å†…è¨³:`, {
                    'é ‚ç‚¹ç”Ÿæˆ': `${pointGenTime.toFixed(2)}ms (${(pointGenTime/totalTime*100).toFixed(1)}%)`,
                    'ä¸‰è§’åˆ†å‰²': `${delaunayTime.toFixed(2)}ms (${(delaunayTime/totalTime*100).toFixed(1)}%)`,
                    'æç”»å‡¦ç†': `${renderTime.toFixed(2)}ms (${(renderTime/totalTime*100).toFixed(1)}%)`
                });
                
                document.getElementById('info').textContent = `${delaunay.triangles.length}å€‹ã®ä¸‰è§’å½¢ã§å¤‰æ›å®Œäº†ï¼`;
                document.getElementById('processBtn').disabled = false;
            }, 10);
        }
        
        function generatePoints(imageData, count, edgeSensitivity) {
            const width = imageData.width;
            const height = imageData.height;
            const points = [];
            
            // å››éš…ã‚’è¿½åŠ 
            points.push([0, 0]);
            points.push([width - 1, 0]);
            points.push([0, height - 1]);
            points.push([width - 1, height - 1]);
            
            // ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆç°¡æ˜“ç‰ˆSobelï¼‰
            console.log('  ã‚¨ãƒƒã‚¸æ¤œå‡ºå®Ÿè¡Œä¸­...');
            const edgeDetectStart = performance.now();
            const edges = detectEdges(imageData);
            console.log(`  ã‚¨ãƒƒã‚¸æ¤œå‡ºå®Œäº† (${(performance.now() - edgeDetectStart).toFixed(2)}ms)`);
            
            // ã‚¨ãƒƒã‚¸ã®å¼·åº¦ã«åŸºã¥ã„ã¦ç‚¹ã‚’é…ç½®
            const edgePoints = Math.floor(count * edgeSensitivity);
            const randomPoints = count - edgePoints - 4;
            
            // ã‚¨ãƒƒã‚¸ä¸Šã«ç‚¹ã‚’é…ç½®
            console.log('  ã‚¨ãƒƒã‚¸ãƒ”ã‚¯ã‚»ãƒ«ã‚’åé›†ä¸­...');
            const edgePixels = [];
            for (let y = 1; y < height - 1; y += 2) {
                for (let x = 1; x < width - 1; x += 2) {
                    const idx = y * width + x;
                    if (edges[idx] > 30) {
                        edgePixels.push([x, y, edges[idx]]);
                    }
                }
            }
            console.log(`  ${edgePixels.length}å€‹ã®ã‚¨ãƒƒã‚¸ãƒ”ã‚¯ã‚»ãƒ«ã‚’æ¤œå‡º`);
            
            // ã‚¨ãƒƒã‚¸ã®å¼·åº¦ã§ã‚½ãƒ¼ãƒˆ
            edgePixels.sort((a, b) => b[2] - a[2]);
            
            // ä¸Šä½ã®ã‚¨ãƒƒã‚¸ãƒ”ã‚¯ã‚»ãƒ«ã‚’é¸æŠ
            for (let i = 0; i < Math.min(edgePoints, edgePixels.length); i++) {
                points.push([edgePixels[i][0], edgePixels[i][1]]);
            }
            console.log(`  ${Math.min(edgePoints, edgePixels.length)}å€‹ã®ã‚¨ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹é ‚ç‚¹ã‚’è¿½åŠ `);
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªç‚¹ã‚’è¿½åŠ 
            for (let i = 0; i < randomPoints; i++) {
                points.push([
                    Math.random() * width,
                    Math.random() * height
                ]);
            }
            console.log(`  ${randomPoints}å€‹ã®ãƒ©ãƒ³ãƒ€ãƒ é ‚ç‚¹ã‚’è¿½åŠ `);
            
            return points;
        }
        
        function detectEdges(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const edges = new Float32Array(width * height);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«å€¤ã‚’è¨ˆç®—
                    const gray = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;
                    
                    // Sobelãƒ•ã‚£ãƒ«ã‚¿ï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    const idx_top = ((y - 1) * width + x) * 4;
                    const idx_bottom = ((y + 1) * width + x) * 4;
                    const idx_left = (y * width + (x - 1)) * 4;
                    const idx_right = (y * width + (x + 1)) * 4;
                    
                    const gray_top = data[idx_top] * 0.299 + data[idx_top + 1] * 0.587 + data[idx_top + 2] * 0.114;
                    const gray_bottom = data[idx_bottom] * 0.299 + data[idx_bottom + 1] * 0.587 + data[idx_bottom + 2] * 0.114;
                    const gray_left = data[idx_left] * 0.299 + data[idx_left + 1] * 0.587 + data[idx_left + 2] * 0.114;
                    const gray_right = data[idx_right] * 0.299 + data[idx_right + 1] * 0.587 + data[idx_right + 2] * 0.114;
                    
                    const gx = gray_right - gray_left;
                    const gy = gray_bottom - gray_top;
                    
                    edges[y * width + x] = Math.sqrt(gx * gx + gy * gy);
                }
            }
            
            return edges;
        }
        
        function getAverageColor(imageData, triangle, width, height) {
            const data = imageData.data;
            let r = 0, g = 0, b = 0, count = 0;
            
            // ä¸‰è§’å½¢ã®å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
            const minX = Math.max(0, Math.floor(Math.min(triangle[0][0], triangle[1][0], triangle[2][0])));
            const maxX = Math.min(width - 1, Math.ceil(Math.max(triangle[0][0], triangle[1][0], triangle[2][0])));
            const minY = Math.max(0, Math.floor(Math.min(triangle[0][1], triangle[1][1], triangle[2][1])));
            const maxY = Math.min(height - 1, Math.ceil(Math.max(triangle[0][1], triangle[1][1], triangle[2][1])));
            
            // ä¸‰è§’å½¢å†…ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            for (let y = minY; y <= maxY; y += 2) {
                for (let x = minX; x <= maxX; x += 2) {
                    if (pointInTriangle([x, y], triangle)) {
                        const idx = (y * width + x) * 4;
                        r += data[idx];
                        g += data[idx + 1];
                        b += data[idx + 2];
                        count++;
                    }
                }
            }
            
            if (count === 0) {
                // ä¸‰è§’å½¢ãŒå°ã•ã™ãã‚‹å ´åˆã¯é‡å¿ƒã®è‰²ã‚’ä½¿ç”¨
                const centerX = Math.floor((triangle[0][0] + triangle[1][0] + triangle[2][0]) / 3);
                const centerY = Math.floor((triangle[0][1] + triangle[1][1] + triangle[2][1]) / 3);
                const idx = (centerY * width + centerX) * 4;
                return {
                    r: data[idx],
                    g: data[idx + 1],
                    b: data[idx + 2]
                };
            }
            
            return {
                r: Math.round(r / count),
                g: Math.round(g / count),
                b: Math.round(b / count)
            };
        }
        
        function pointInTriangle(p, triangle) {
            const [p0, p1, p2] = triangle;
            const area = 0.5 * (-p1[1] * p2[0] + p0[1] * (-p1[0] + p2[0]) + p0[0] * (p1[1] - p2[1]) + p1[0] * p2[1]);
            const s = 1 / (2 * area) * (p0[1] * p2[0] - p0[0] * p2[1] + (p2[1] - p0[1]) * p[0] + (p0[0] - p2[0]) * p[1]);
            const t = 1 / (2 * area) * (p0[0] * p1[1] - p0[1] * p1[0] + (p0[1] - p1[1]) * p[0] + (p1[0] - p0[0]) * p[1]);
            
            return s >= 0 && t >= 0 && (1 - s - t) >= 0;
        }
        
        // ãƒ‡ãƒ¢ç”¨ã®ã‚µãƒ³ãƒ—ãƒ«ç”»åƒã‚’è‡ªå‹•ç”Ÿæˆ
        window.addEventListener('load', function() {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
            const gradient = ctx.createRadialGradient(200, 200, 0, 200, 200, 200);
            gradient.addColorStop(0, '#ff6b6b');
            gradient.addColorStop(0.5, '#4ecdc4');
            gradient.addColorStop(1, '#45b7d1');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 400, 400);
            
            // ã„ãã¤ã‹ã®å›³å½¢ã‚’è¿½åŠ 
            ctx.fillStyle = '#f7b731';
            ctx.beginPath();
            ctx.arc(150, 150, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#5f27cd';
            ctx.fillRect(250, 250, 100, 100);
            
            ctx.fillStyle = '#00d2d3';
            ctx.beginPath();
            ctx.moveTo(300, 100);
            ctx.lineTo(350, 180);
            ctx.lineTo(250, 180);
            ctx.closePath();
            ctx.fill();
            
            // ç”»åƒã¨ã—ã¦èª­ã¿è¾¼ã¿
            canvas.toBlob(function(blob) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    displayOriginal();
                    document.getElementById('info').textContent = 'ã‚µãƒ³ãƒ—ãƒ«ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚å¤‰æ›å®Ÿè¡Œã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã‹ã€æ–°ã—ã„ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚';
                };
                img.src = URL.createObjectURL(blob);
            });
        });
    </script>
</body>
</html>
